<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Battlesnake Programming Competition 2018</title><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/7fa966dbd227c5e1.css" as="style"/><link rel="stylesheet" href="/_next/static/css/7fa966dbd227c5e1.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-4db07a2bf5ab24b4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-7e1c83480a10cb30.js" defer=""></script><script src="/_next/static/chunks/182-e5aba423b8812655.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-47b2823eb5b64be6.js" defer=""></script><script src="/_next/static/_A1aUm7lgmk1WrrLd9Xyv/_buildManifest.js" defer=""></script><script src="/_next/static/_A1aUm7lgmk1WrrLd9Xyv/_ssgManifest.js" defer=""></script><script src="/_next/static/_A1aUm7lgmk1WrrLd9Xyv/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="toggle-container"><span role="img" tabindex="-1" class="anticon"><svg class="toggle-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128"><path class="sun-icon" d="M 4 1 C 3.225 1 2.4503906 1.3003906 1.9003906 1.9003906 C 0.70039063 3.1003906 0.70039063 4.9996094 1.9003906 6.0996094 L 11.199219 15.5 C 11.799219 16.1 12.600781 16.400391 13.300781 16.400391 C 14.000781 16.400391 14.800391 16.1 15.400391 15.5 C 16.600391 14.3 16.600391 12.400781 15.400391 11.300781 L 6.0996094 1.9003906 C 5.5496094 1.3003906 4.775 1 4 1 z M 24 1 A 3 3 0 0 0 24 7 A 3 3 0 0 0 24 1 z M 124 1 C 123.225 1 122.45039 1.3003906 121.90039 1.9003906 L 113.90039 9.9003906 C 112.70039 11.100391 112.70039 12.999609 113.90039 14.099609 C 114.50039 14.699609 115.3 15 116 15 C 116.7 15 117.49961 14.699609 118.09961 14.099609 L 126.09961 6.0996094 C 127.29961 4.8996094 127.29961 3.0003906 126.09961 1.9003906 C 125.54961 1.3003906 124.775 1 124 1 z M 48.009766 4.5644531 C 46.992578 4.5550781 45.975 4.7 45 5 C 42.4 5.9 40.199609 7.8003906 39.099609 10.400391 C 38.399609 11.900391 39.099219 13.700781 40.699219 14.300781 C 41.999219 15.000781 43.700391 14.299219 44.400391 12.699219 C 44.800391 11.699219 45.599219 10.999609 46.699219 10.599609 C 47.699219 10.299609 48.799219 10.400391 49.699219 10.900391 L 59 16.400391 C 62 18.200391 65.800391 18.200391 68.900391 16.400391 L 78.199219 10.900391 C 79.099219 10.400391 80.199219 10.199609 81.199219 10.599609 C 82.199219 10.899609 83 11.699219 83.5 12.699219 L 87.800781 22.599609 C 88.300781 23.699609 89.399609 24.400391 90.599609 24.400391 C 90.999609 24.400391 91.400781 24.299609 91.800781 24.099609 C 93.300781 23.399609 94.000391 21.699219 93.400391 20.199219 L 89.099609 10.300781 C 87.999609 7.8007813 85.799219 5.8 83.199219 5 C 80.599219 4.2 77.700781 4.5003906 75.300781 5.9003906 L 66 11.400391 C 64.8 12.100391 63.399219 12.100391 62.199219 11.400391 L 52.900391 5.9003906 C 51.400391 5.0253906 49.705078 4.5800781 48.009766 4.5644531 z M 26.421875 22.992188 C 26.220508 22.972656 26.013281 22.975 25.800781 23 L 20.800781 23.5 C 18.000781 23.8 15.400781 25.3 13.800781 27.5 C 12.200781 29.8 11.599219 32.600781 12.199219 35.300781 C 12.499219 36.700781 13.699609 37.699219 15.099609 37.699219 C 15.299609 37.699219 15.500781 37.699609 15.800781 37.599609 C 17.400781 37.199609 18.399609 35.6 18.099609 34 C 17.899609 32.9 18.099219 31.9 18.699219 31 C 19.299219 30.1 20.300391 29.6 21.400391 29.5 L 26.400391 29 C 28.000391 28.8 29.299609 27.399219 29.099609 25.699219 C 28.924609 24.299219 27.831445 23.128906 26.421875 22.992188 z M 106.67773 23.488281 C 105.26816 23.607227 104.175 24.711719 104 26.199219 C 103.8 27.799219 104.99922 29.3 106.69922 29.5 C 107.79922 29.6 108.70039 30.1 109.40039 31 C 110.00039 31.9 110.3 32.9 110 34 L 107.69922 44.599609 C 106.89922 47.999609 108.09922 51.6 110.69922 54 L 118.80078 61.199219 C 119.60078 61.899219 120.09961 62.9 120.09961 64 C 120.09961 65.1 119.70078 66.100781 118.80078 66.800781 L 110.69922 74 C 108.09922 76.3 106.89922 79.900391 107.69922 83.400391 L 110 94 C 110.2 95.1 110.00039 96.1 109.40039 97 C 108.70039 97.8 107.79922 98.4 106.69922 98.5 C 105.09922 98.7 103.8 100.10078 104 101.80078 C 104.1 103.40078 105.5 104.5 107 104.5 L 107.30078 104.5 C 110.10078 104.2 112.59922 102.8 114.19922 100.5 C 115.79922 98.2 116.40078 95.399219 115.80078 92.699219 L 113.5 82.099609 C 113.2 80.799609 113.69922 79.4 114.69922 78.5 L 122.80078 71.300781 C 124.90078 69.500781 126.09961 66.8 126.09961 64 C 126.09961 61.2 124.90078 58.599219 122.80078 56.699219 L 114.69922 49.5 C 113.69922 48.6 113.2 47.200391 113.5 45.900391 L 115.80078 35.300781 C 116.40078 32.600781 115.79922 29.7 114.19922 27.5 C 112.59922 25.2 110.00078 23.8 107.30078 23.5 C 107.08828 23.475 106.8791 23.471289 106.67773 23.488281 z M 64 30 C 45.2 30 30 45.2 30 64 C 30 82.8 45.2 98 64 98 C 82.8 98 98 82.8 98 64 C 98 45.2 82.8 30 64 30 z M 64 37 C 65.7 37 67 38.3 67 40 C 67 41.7 65.7 43 64 43 C 62.7 43 61.3 43.100391 60 43.400391 C 59.8 43.400391 59.600391 43.5 59.400391 43.5 C 58.000391 43.5 56.7 42.499609 56.5 41.099609 C 56.2 39.399609 57.200781 37.8 58.800781 37.5 C 60.500781 37.2 62.2 37 64 37 z M 17.296875 42.246094 C 17.099219 42.244336 16.899219 42.263281 16.699219 42.300781 C 15.099219 42.700781 14.100391 44.300391 14.400391 45.900391 C 14.700391 47.200391 14.199219 48.6 13.199219 49.5 L 5.0996094 56.699219 C 3.0996094 58.599219 1.9003906 61.2 1.9003906 64 C 1.9003906 66.8 3.0992187 69.400781 5.1992188 71.300781 L 13.300781 78.5 C 14.300781 79.4 14.8 80.799609 14.5 82.099609 L 12.199219 92.699219 C 11.599219 95.399219 12.200781 98.3 13.800781 100.5 C 15.400781 102.8 17.999219 104.2 20.699219 104.5 L 31.5 105.5 C 32.8 105.6 33.999609 106.49922 34.599609 107.69922 L 38.900391 117.59961 C 39.400391 118.69961 40.499219 119.40039 41.699219 119.40039 C 42.099219 119.40039 42.500391 119.29961 42.900391 119.09961 C 44.400391 118.39961 45.1 116.69922 44.5 115.19922 L 40.199219 105.30078 C 38.799219 102.10078 35.699219 99.8 32.199219 99.5 L 21.400391 98.5 C 20.300391 98.4 19.399219 97.9 18.699219 97 C 17.999219 96.1 17.8 95 18 94 L 20.300781 83.400391 C 21.100781 80.000391 19.900781 76.4 17.300781 74 L 9.1992188 66.800781 C 8.3992187 66.100781 7.9003906 65.1 7.9003906 64 C 7.9003906 62.9 8.2992188 61.899219 9.1992188 61.199219 L 17.300781 54 C 19.900781 51.7 21.100781 48.099609 20.300781 44.599609 C 19.950781 43.199609 18.680469 42.258398 17.296875 42.246094 z M 43.992188 47.744141 C 44.578711 47.746484 45.174219 47.925781 45.699219 48.300781 C 47.099219 49.200781 47.5 51.1 46.5 52.5 C 44.2 55.9 43 59.9 43 64 C 43 69.6 45.199219 74.900781 49.199219 78.800781 C 50.399219 80.000781 50.399219 81.9 49.199219 83 C 48.599219 83.7 47.8 84 47 84 C 46.2 84 45.500391 83.699609 44.900391 83.099609 C 39.800391 77.999609 37 71.2 37 64 C 37 58.7 38.5 53.499609 41.5 49.099609 C 42.0625 48.224609 43.014648 47.740234 43.992188 47.744141 z M 90.613281 103.52734 C 89.511719 103.49922 88.425391 104.17578 87.900391 105.30078 L 83.599609 115.19922 C 83.199609 116.19922 82.400781 116.90078 81.300781 117.30078 C 80.300781 117.60078 79.200781 117.5 78.300781 117 L 69 111.5 C 66 109.7 62.199609 109.7 59.099609 111.5 L 49.800781 117 C 48.400781 117.8 47.899219 119.69961 48.699219 121.09961 C 49.499219 122.49961 51.400781 122.99922 52.800781 122.19922 L 62.099609 116.69922 C 63.299609 115.99922 64.700391 115.99922 65.900391 116.69922 L 75.199219 122.19922 C 76.699219 123.09922 78.399609 123.5 80.099609 123.5 C 81.099609 123.5 82.099609 123.3 83.099609 123 C 85.699609 122.1 87.9 120.19961 89 117.59961 L 93.300781 107.69922 C 94.000781 106.19922 93.299219 104.40078 91.699219 103.80078 C 91.349219 103.62578 90.980469 103.53672 90.613281 103.52734 z M 113.36328 110.5 C 112.60078 110.5 111.85078 110.80039 111.30078 111.40039 C 110.10078 112.60039 110.10078 114.49961 111.30078 115.59961 L 121.90039 126.09961 C 122.50039 126.69961 123.2 127 124 127 C 124.8 127 125.49961 126.69961 126.09961 126.09961 C 127.29961 124.89961 127.29961 123.00039 126.09961 121.90039 L 115.5 111.40039 C 114.9 110.80039 114.12578 110.5 113.36328 110.5 z"></path></svg></span></div><section class="ant-layout app"><main class="ant-layout-content fadeIn"><div id="sticky-header" class="sticky-header sticky-header-hidden"><span class="anchor"><a href="/">Home</a></span><span role="img" aria-label="swap-right" class="anticon anticon-swap-right"><svg viewBox="0 0 1024 1024" focusable="false" data-icon="swap-right" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M873.1 596.2l-164-208A32 32 0 00684 376h-64.8c-6.7 0-10.4 7.7-6.3 13l144.3 183H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h695.9c26.8 0 41.7-30.8 25.2-51.8z"></path></svg></span>blog<span role="img" aria-label="swap-right" class="anticon anticon-swap-right"><svg viewBox="0 0 1024 1024" focusable="false" data-icon="swap-right" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M873.1 596.2l-164-208A32 32 0 00684 376h-64.8c-6.7 0-10.4 7.7-6.3 13l144.3 183H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h695.9c26.8 0 41.7-30.8 25.2-51.8z"></path></svg></span>Battlesnake Programming Competition 2018</div><div>
          <h1 id="battlesnake-programming-competition-2018">Battlesnake Programming Competition 2018</h1>
        
          <h4 id="june-11-2018">June 11, 2018</h4>
        <p>
        <img src="/images/posts/Battlesnake2018-1.jpg" alt="null" class="article-image" />
    </p>

          <h2 id="tldr">
            <span class="underline">Tl;dr</span>
          </h2>
        <ul>
<li><a href="#background">Background</a>: Battlesnake is a programming competition where students and industry professionals develop an AI to play a multiplayer version of the classic game Snake.</li>
<li><a href="#first-year-competing">First Year Competing</a>: I was very excited to discover this competition and thought it would be a great way to learn Python.</li>
<li><a href="#getting-started">Getting Started</a>: Set up a basic &quot;starter snake&quot; provided by sendwithus.</li>
<li><a href="#learning-the-a-algorithm">Learning the A* Algorithm</a>: After getting use to Python and concept of Battlesnake, I needed to give my snake some smarts.</li>
<li><a href="#building-a-flood-fill-algorithm">Building a Flood Fill Algorithm</a>: Now that my snake could find its way around, it needed to see beyond its target.</li>
<li><a href="#basic-behaviour-switching">Basic Behaviour Switching</a>: With a few basic behaviors coded, I needed to be able to switch between them given some parameters.</li>
<li><a href="#aggressive-behaviour">Aggressive Behaviour</a>: Basic survival is taken care of. Now I wanted to be able to hunt my opponents.</li>
<li><a href="#the-event">The Event</a>: The competition consists of a &quot;Bounty Snake&quot; section where you can challenge the sponsors to duels. After that is the tournament itself composed of beginner, intermediate, and expert divisions.</li>
<li><a href="#conclusion">Conclusion</a>: Super fun event! You should go!</li>
<li><a href="https://github.com/tyrelh/battlesnake2018">Code</a> for my 2018 entry is on Github.</li>
</ul>

          <h2 id="background">
            <span class="underline">Background</span>
          </h2>
        <p><a href="https://www.battlesnake.io/">Battlesnake</a> is a programming competition where competitors develop an AI to play a multiplayer version of the classic game <a href="https://en.wikipedia.org/wiki/Snake_(video_game_genre)">Snake</a>. Competitors can be individuals or groups; they are mainly students and industry professionals.</p>
<p>My first time entering the competition was this year, but the first version of the event was in 2013; it began as a small, friendly programming competition between a few colleagues at sendwithus (now <a href="https://www.dyspatch.io/sendwithus/">Dyspatch</a>).</p>
<p>A “snake” is essentially an API (Application Program Interface). This API has several required endpoints such as <code>start</code> and <code>move</code>. For every move, the game server will send a POST request to each snake&#39;s <code>move</code> endpoint, with the entire game state in the body of the request. You have 250ms (including your network transit time) to respond with a move, either “up”, “down”, “left”, or “right”.</p>
<p>Once each snake has responded, the moves are played out on the board simultaneously. If a snake hits a wall or another snake&#39;s body, it dies. If a snake eats food, it grows by one segment. If two snakes collide head-on the smaller snake will die. The object of the game is to be the last snake alive.</p>
<p>The competition is divided into three categories: beginner, intermediate, and expert. Within each bracket there is a round-robin tournament to determine the winners.</p>
<p>During the day-long event there are many different activities. Early in the day there is the opportunity for newcomers to set up and begin developing their AI from scratch. Experienced developers are there to provide assistance in developing and deploying fresh snakes. Midway through the day are the bounty snake challenges; sponsors of the event challenge participants to duel their snakes for prizes. Sponsors with bounty snakes can opt to have their own unique rules to the game, forcing challengers to adapt their strategies the day of the event. Prizes for besting a bounty snake vary from t-shirts and stickers, to entries into a raffle for bigger prizes. Around 4pm, the main tournament begins. Starting with the beginner division, each tournament is played out on a big screen for all the participants to watch. The whole thing is also <a href="https://www.twitch.tv/battlesnakeofficial">streamed on Twitch</a>. Prizes of up to $4,000 are awarded for a podium placing.</p>
<p>
        <img src="/images/posts/Battlesnake2018-2.jpg" alt="null" class="article-image" />
    </p>

          <h2 id="first-year-competing">
            <span class="underline">First Year Competing</span>
          </h2>
        <p>Going into this I wasn’t sure what to expect. I just just really getting into the idea of software development in my second year of a Computer Science degree and was eager to try out some of my new skills.</p>
<p>One of the great (and overwhelming!) things about a competition like this is that there are essentially infinite ways of approaching the task. Some people do tree searches through the possible board states, some people build a more specific AI architecture, some even have started incorporating machine learning into their snakes. I’m not sure if any strategy is the best strategy, and this is just me documenting my journey and particular strategies as I became fascinated with this game.</p>

          <h2 id="getting-started">
            <span class="underline">Getting Started</span>
          </h2>
        <p>I decided to write my first entry in Python. I had been into Java for a while with school and was excited to learn Python; and what a better opportunity. I began with one of the <a href="https://github.com/BattlesnakeOfficial/starter-snake-node">provided “starter snakes”</a> which are basic repositories with a simple server setup with the required endpoints, but no logic within those endpoints. Generally the starter snakes just <code>move</code> up upon a move request.</p>
<p>With the starter snake as a base, my first goal was to get the snake to chase its tail. Circling on your own tail seems to be a tried-and-tested method for basic survival so that seemed like a good place to start. Looping over an array of directions and returning a new one each time lets you blindly return a new direction each time. This sort of works, but the snake is still unaware of its surroundings and will still bump into walls, other snakes and even itself occasionally. The snake really needs some eyes so it can see if the next move is deadly or ok.</p>
<p>I decided the simplest was to do this was to build myself a representation of the board. Each turn you are sent the board dimensions (which don’t change during the course of a round, but could change round-to-round), locations of all the snakes (for each snake a list of the positions of each body segment), and a list of food locations. At the start of each turn, I build a 2-dimensional array representing the game board, and plot all the snakes and food on it. I set up a simple numbering system representing the different possible board cells in a sort of increasing danger rating. 0 for space, 1 for food, 2 for snake body, and out of bounds represents the board edges. Now, after I pick a move, I can determine what the x, y coordinates of that move will be based on my current location, and I can check if that move will kill me or not based on the current board state. If it is deadly, pick another move. Basic sight!</p>
<p>With just this simple start your snake can spin around in a circle and survive for a while. The problem now is that you have an ever decreasing amount of health, and you need to eat food to replenish it. You begin with 100 health, and each move you take this is decremented by 1. If you reach 0 you die. So you have to eat! But in order to find food reliably when you are getting hungry, your snake will need more smarts that just its basic sense of sight.</p>

          <h2 id="learning-the-a-algorithm">
            <span class="underline">Learning the A* Algorithm</span>
          </h2>
        <p>In order to choose a move that will get you closer to a particular destination, you will need to implement some form of pathfinding. When looking into pathfinding algorithms, <a href="https://en.wikipedia.org/wiki/A*_search_algorithm">A*</a> almost always comes up at the top of the list. I would struggle to explain A*, but the resource I used to initially learn and implement the algorithm was a video from <a href="https://shiffman.net/">Daniel Shiffman</a> titled <a href="https://www.youtube.com/watch?v=aKYlikFAV4k">A* Pathfinding Algorithm</a>. He guides you through the algorithm and you can follow along and implement it in JavaScript with the <a href="https://p5js.org/">p5.js</a> library. You can find my original implementation on <a href="https://github.com/tyrelh/a-star-p5.js">Github</a>. Also if you are building your snake with JavaScript and NodeJS, you can just reuse this code! For my first snake I translated this code into Python.</p>
<p>With this algorithm you can find the shortest path between a start point and a destination. Your start point will likely be your current head location, and the first destination point I choose was the closest food. I originally wrote this algorithm with my snake’s head and the closest food sort of hard-wired in, but later refactored it so that I can pass in any arbitrary start and destination points I want. Also within the algorithm you want to tell it to treat out of bounds as well as all snake body segments as “no go” areas. Basically the walls or obstacles that you are finding a path around. Within the search function I wrote, once you have found the optimal path to your destination, what you actually need from it is which direction to go next. Basically every turn you will be doing this search and just moving whatever it tells you the next move should be. There is no sense in recording or remembering the whole path as the game is filled with other snakes that are also moving every turn, so the optimal path may change from turn to turn.</p>
<p>One other thing to note is that there is often no path to where you want to go. Maybe a food exists on the board but is completely blocked from you on the current turn by other snakes. You just want to make sure you are handling situations like this gracefully and avoiding exceptions or other “panic” behaviour that might creep up. Develop a strategy for when you are unsure which move will get you closer to your destination.</p>
<p>An optimisation to the earlier tail-following behavior is that you can now use this A* algorithm to find the best move that brings you closer to your tail! You can just pass your tail location to the algorithm rather than a food location as the destination. This is a more robust way to follow your tail rather than looping through a series of moves as I initially implemented. Using the A* search allows you to be any size and anywhere on the board. It also makes it so you can follow yourself clockwise or counter-clockwise depending on which is better given the board state, as well as navigate effectively if you are touching other snakes.</p>
<p>Now that my snake could find food it could survive much longer than 100 turns! At this level you could be well into the beginner category. Unfortunately every time you improve your snakes smarts and survivability, new problems pop up. The next glaring issue that I began to notice is that my snake loved to travel down dead ends. The snake was smart enough to find a food and seek it out, but not to plan for what would happen after it got to it.</p>

          <h2 id="building-a-flood-fill-algorithm">
            <span class="underline">Building a Flood Fill Algorithm</span>
          </h2>
        <p>The behaviour I thought of to combat this tendency was an algorithm to measure how large a space was. If the space is too small to fit, or if another direction would lead to a large open area, the snake would take that into account when choosing the next move.</p>
<p>Sidenote: This was the moment when I should have realized that a move scoring system was the way to go. Next year I would implement this with great success, but this first year I basically stuck to a bunch of <code>if</code>/<code>else</code> statements. It is really difficult to balance the importance of different signals if you don’t have some kind of weights on them that you can tune. For example, if you have two possible moves, left and right, and there is food to the left, but much more space to the right, how do you value them? Which move do you choose? With a scoring system, you can apply a score to each move and sum them up in the end, choosing the move with the highest score. This is what I went on to build next year, but more on that in a different post.</p>
<p>I believe what I was doing last year was testing to see if my snake length could fit into the area accessible by my next move. I would do my A* search first to see which direction I would prefer to go, and then do the flood fill on that move to see if I can fit. If I couldn’t fit I would choose a different move, abandoning my pursuit of food. This approach helps you to avoid these small areas that will easily trap you, but tramples over a lot of subtlety. For example, if there are snake tails within the area, that area will be expanding, so it is much more strategic for you to move into it. In the same vein, if there are snake heads within the area, the space will fill up as the game progresses. Taking these into consideration is a really good idea.</p>
<p>A great tip for beginner programmers is that when you are developing and writing these algorithms, try to write them in reusable ways. Avoid hard-coding your snake to behave in one way.</p>

          <h2 id="basic-behaviour-switching">
            <span class="underline">Basic Behaviour Switching</span>
          </h2>
        <p>My snake at this point has two different behaviors available to it. The first is to follow its own tail and the second is to seek out food. So long as you wrote your search algorithms in a way that you can pass any destination to them, it is pretty trivial to switch between these behaviours.</p>
<p>All I did to start was to switch between them based on my health level. If my health remaining was high, I would follow my tail. If my health was low, I would seek out food. This behaviour is what has become known as “chicken-snake” behaviour. Before I learned about Battlesnake, a now infamous player first developed this basic strategy to much success (coming in 2nd overall I believe). I guess people thought it looked like a chicken running around with it’s head cut off (sorry for the imagery).</p>
<p>So long as your algorithms are robust, and your snake doesn&#39;t make very many mistakes, this technique can still get you pretty far, perhaps even into the expert bracket. But because this behaviour became so popular, I decided I would actually see if I could build my snake to counter it.</p>

          <h2 id="aggressive-behaviour">
            <span class="underline">Aggressive Behaviour</span>
          </h2>
        <p>Now that my snake had some basic survival skills, I wanted to try to do something a little different. I got the idea of trying to make my snake actively aggressive towards its opponents.</p>
<p>When two snakes move in to the same space it is a head-on collision, and the rules state that if one snake is larger than the other the smaller snake will die. When a snake dies in the game all of its body segments are immediately removed from the board.</p>
<p>So my plan was to use my A* algorithm to seek out other snake heads. Strictly speaking, I would not target their head, but target the next move that then can make. So I altered my initial board state creation to mark <code>KILL_ZONE</code> for spaces a smaller snake than me could move next, and <code>DANGER_ZONE</code> for spaces a larger or equal size snake than me could move next. So now my board had these possible cell states:</p>
<ol>
<li><code>SPACE</code></li>
<li><code>KILL_ZONE</code></li>
<li><code>FOOD</code></li>
<li><code>DANGER_ZONE</code></li>
<li><code>SNAKE_BODY</code></li>
</ol>
<p>I ranked them in order of danger so that in my A* algorithm when testing if a cell is a valid spot for a path I can simply test if its board value is &lt; <code>SNAKE_BODY</code>.</p>
<p>Now with the <code>KILL_ZONE</code> markings available, I could simply find the one closest to myself and use my A* to target it.</p>
<p>The next thing I wanted to do was to insure I was the biggest snake on the board, so that I could aggress any other snake I wanted. In the section of my code where I was determining which behaviour to use, I would not only test to see if I needed to eat because of hunger, but also if I needed to eat because I wasn’t the longest snake on the board. This behaviour works well sometimes but it has the fatal flaw that there can be other snakes with the same behaviour. You both can get into a feeding frenzy where you are always trying to get bigger than the other snake. You end up getting really long and it is only a matter of time before one of you makes a mistake and gets trapped. I did not fix this issue for this year and it seemed alright, just something to keep in mind.</p>
<p>So now my snake will eat if it is hungry or if there are any larger snakes, and it will target the nearest smaller snake if it is the largest on the board. I actually found that this simple behaviour has some really interesting and powerful emergent behaviours that I didn’t code for.</p>
<p>The first that I noticed is that it is very effective at dealing with the “chicken-snake” strategy. As a chicken snake is spinning away, minding its own business, my snake would be targeting its head. Since the other snake is smaller and spinning in a ball, my snake would wrap around it, trapping it. When the “chicken-snake” decided it had been spinning for long enough and it was time to eat, there was nowhere to go. Chances were that it might not be able to escape and get to food. If I didn’t kill it first by a head-on collision, I might be able to starve it.</p>
<p>The other interesting behaviour I noticed is similar to above, but instead of surrounding the opponent snake, I would block it against a wall. My snake wasn’t smart enough to notice if it could create a dead end for the other snake, but it could keep it against the wall for a long time, starving it.</p>
<p>This aggressive behaviour actually seemed to work very well. 1-1 my snake was quite strong at this point (a friend of mine who went on to win 2nd place in the intermediate division I could defeat almost all the time 1-1).</p>
<p>There are a few oversights in my strategy up to this point that I was aware of, but had run out of time to address. One was the eating behaviour that could lead to me getting very big and potentially kill myself. Another was that I didn’t necessarily need to be the biggest snake on the board at all times. There are plenty of opportunities to act aggressive to larger snakes while staying small. And lastly, but more importantly, there were still tons of small bugs and edge cases that I just wasn’t accounting for. There were still cases where given two possible moves, my snake was unable to see far enough ahead, or see in enough detail, to choose the best one. Building a robust logging solution is a must so that you can look back one a game to the move where your snake made a vital decision and you can debug why it may have made the wrong one. I had some basic console logging at this point but nothing nearly good enough.</p>
<p>But time to work on it was winding down, and the event was coming up.</p>

          <h2 id="the-event">
            <span class="underline">The Event</span>
          </h2>
        <p>In the morning people can converse and mingle, and newcomers can get help on getting their snakes setup and working. It’s great to hang out with your friends and work through some of your last bugs. Then lunch is provided by a bunch of great food trucks from around town. <a href="https://www.deadbeetz.com/">Dead Beetz</a> is definitely my favorite go-to burger!</p>
<p>After lunch the Bounty Snake challenge opens to everyone. This part is a lot of fun. You are able to visit each sponsor’s booth where they usually have some free swag. But also, more crucially, they have a snake of their own that you can challenge to a dual. Each sponsor has different prizes available to competitors who can defeat their snake. This year I actually won a terrific prize of $1000 from the local company <a href="https://www.rooof.com/">Rooof</a>!</p>
<p>Around 4:00 is when the actual competition begins. The setup this year was fantastic. They had two projectors showing the live games to an audience of around 800 people. They had live commentary and were also streaming the entire event live on <a href="https://www.twitch.tv/battlesnakeofficial">Twitch</a>. They do each bracket separately moving from Beginner to Intermediate and then Expert.</p>
<p>I participated in Beginner this year as it was my first event. I was actually a little worried that my snake was too strong for beginner as I knew that some people entering had only started on their AI that day. Well I would be proven very wrong on that front. I won the first round I played and made it to the next head which was very exciting indeed. But alas I was knocked out in the next round, seemingly to some kind of bug (my snake hit another snake with possible move to avoid it existing). Oh well! It was so much fun to watch all the other snakes compete and to see everyones interesting and novel strategies. The top player in the expert division won $5,000, and in his little acceptance speech he said he was very glad to win as this money will partly cover his AWS bills for his snake! Holy cow!</p>
<p>During the tournament, the music playlist left much to be desired. This gem came on part way through the night and everyone thought it was a custom &quot;Battlesnake&quot; theme song and loved it! Only later did we learn they were saying &quot;rattlesnake&quot; not &quot;battlesnake&quot;.</p>
<div className="video-container">
    <iframe
        width="853"
        height="480"
        title="King Gizzard and The Lizard Wizard - Rattlesnake"
        src="https://www.youtube.com/embed/Q-i1XZc8ZwA"
        frameBorder="0"
        allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
        allowFullScreen
    />
</div>


          <h2 id="conclusion">
            <span class="underline">Conclusion</span>
          </h2>
        <p>I think this is such a great event to participate in. The challenge itself of creating an AI to play this game a great way to practice and build your coding skills. Everyone has the same 250ms to respond to each move request, but what you do in that time is all up to you. It is accessible to beginner programmers, but still an interesting challenge for a seasoned professional. I had a great time connecting with other students and industry professionals. I see myself participating every year that I can!</p>
<p>My code for 2018 is available on <a href="https://github.com/tyrelh/battlesnake2018">Github</a>.</p>
<p>I&#39;ll see you next year,
ZeroCool</p>
</div><footer class="ant-layout-footer"><p>Made with <span role="img" aria-label="thunderbolt" class="anticon anticon-thunderbolt"><svg viewBox="64 64 896 896" focusable="false" data-icon="thunderbolt" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M848 359.3H627.7L825.8 109c4.1-5.3.4-13-6.3-13H436c-2.8 0-5.5 1.5-6.9 4L170 547.5c-3.1 5.3.7 12 6.9 12h174.4l-89.4 357.6c-1.9 7.8 7.5 13.3 13.3 7.7L853.5 373c5.2-4.9 1.7-13.7-5.5-13.7z"></path></svg></span> by Tyrel Hiebert   <span class="anchor"><a href="https://twitter.com/tyrelhiebert" target="_blank" rel="noopener noreferrer"><span role="img" aria-label="twitter" class="anticon anticon-twitter"><svg viewBox="64 64 896 896" focusable="false" data-icon="twitter" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M928 254.3c-30.6 13.2-63.9 22.7-98.2 26.4a170.1 170.1 0 0075-94 336.64 336.64 0 01-108.2 41.2A170.1 170.1 0 00672 174c-94.5 0-170.5 76.6-170.5 170.6 0 13.2 1.6 26.4 4.2 39.1-141.5-7.4-267.7-75-351.6-178.5a169.32 169.32 0 00-23.2 86.1c0 59.2 30.1 111.4 76 142.1a172 172 0 01-77.1-21.7v2.1c0 82.9 58.6 151.6 136.7 167.4a180.6 180.6 0 01-44.9 5.8c-11.1 0-21.6-1.1-32.2-2.6C211 652 273.9 701.1 348.8 702.7c-58.6 45.9-132 72.9-211.7 72.9-14.3 0-27.5-.5-41.2-2.1C171.5 822 261.2 850 357.8 850 671.4 850 843 590.2 843 364.7c0-7.4 0-14.8-.5-22.2 33.2-24.3 62.3-54.4 85.5-88.2z"></path></svg></span></a></span>  <span class="anchor"><a href="https://github.com/tyrelh" target="_blank" rel="noopener noreferrer"><span role="img" aria-label="github" class="anticon anticon-github"><svg viewBox="64 64 896 896" focusable="false" data-icon="github" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M511.6 76.3C264.3 76.2 64 276.4 64 523.5 64 718.9 189.3 885 363.8 946c23.5 5.9 19.9-10.8 19.9-22.2v-77.5c-135.7 15.9-141.2-73.9-150.3-88.9C215 726 171.5 718 184.5 703c30.9-15.9 62.4 4 98.9 57.9 26.4 39.1 77.9 32.5 104 26 5.7-23.5 17.9-44.5 34.7-60.8-140.6-25.2-199.2-111-199.2-213 0-49.5 16.3-95 48.3-131.7-20.4-60.5 1.9-112.3 4.9-120 58.1-5.2 118.5 41.6 123.2 45.3 33-8.9 70.7-13.6 112.9-13.6 42.4 0 80.2 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.3-43.9 2.9 7.7 24.7 58.3 5.5 118 32.4 36.8 48.9 82.7 48.9 132.3 0 102.2-59 188.1-200 212.9a127.5 127.5 0 0138.1 91v112.5c.8 9 0 17.9 15 17.9 177.1-59.7 304.6-227 304.6-424.1 0-247.2-200.4-447.3-447.5-447.3z"></path></svg></span></a></span><br/>This site uses <span class="anchor"><a href="https://plausible.io/" target="_blank" rel="noopener noreferrer">Plausible</a></span> to collect privacy mindful visitor stats<br/><span class="anchor"><a href="https://www.github.com/tyrelh/personal-site/" target="_blank" rel="noopener noreferrer"><span role="img" aria-label="github" class="anticon anticon-github"><svg viewBox="64 64 896 896" focusable="false" data-icon="github" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M511.6 76.3C264.3 76.2 64 276.4 64 523.5 64 718.9 189.3 885 363.8 946c23.5 5.9 19.9-10.8 19.9-22.2v-77.5c-135.7 15.9-141.2-73.9-150.3-88.9C215 726 171.5 718 184.5 703c30.9-15.9 62.4 4 98.9 57.9 26.4 39.1 77.9 32.5 104 26 5.7-23.5 17.9-44.5 34.7-60.8-140.6-25.2-199.2-111-199.2-213 0-49.5 16.3-95 48.3-131.7-20.4-60.5 1.9-112.3 4.9-120 58.1-5.2 118.5 41.6 123.2 45.3 33-8.9 70.7-13.6 112.9-13.6 42.4 0 80.2 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.3-43.9 2.9 7.7 24.7 58.3 5.5 118 32.4 36.8 48.9 82.7 48.9 132.3 0 102.2-59 188.1-200 212.9a127.5 127.5 0 0138.1 91v112.5c.8 9 0 17.9 15 17.9 177.1-59.7 304.6-227 304.6-424.1 0-247.2-200.4-447.3-447.5-447.3z"></path></svg></span> View Source</a></span></p></footer></main></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"title":"Battlesnake Programming Competition 2018","slug":"battlesnake-2018","date":"June 11, 2018","excerpt":"Battlesnake is a programming competition where participants create an AI server that acts as the brain of a snake in the classic game Snake. Participants compete in a round-robin tournament played out live in front of an audience of roughly 1000 people. The winner takes home up to $4,000!","hero":"/images/posts/Battlesnake2018-1.jpg","tags":["python","ai","events"],"content":"# Battlesnake Programming Competition 2018\n#### June 11, 2018\n\n![Battle snake logo on purple background](Battlesnake2018-1.jpg)\n\n## Tl;dr\n* [Background](#background): Battlesnake is a programming competition where students and industry professionals develop an AI to play a multiplayer version of the classic game Snake.\n* [First Year Competing](#first-year-competing): I was very excited to discover this competition and thought it would be a great way to learn Python.\n* [Getting Started](#getting-started): Set up a basic \"starter snake\" provided by sendwithus.\n* [Learning the A* Algorithm](#learning-the-a-algorithm): After getting use to Python and concept of Battlesnake, I needed to give my snake some smarts.\n* [Building a Flood Fill Algorithm](#building-a-flood-fill-algorithm): Now that my snake could find its way around, it needed to see beyond its target.\n* [Basic Behaviour Switching](#basic-behaviour-switching): With a few basic behaviors coded, I needed to be able to switch between them given some parameters.\n* [Aggressive Behaviour](#aggressive-behaviour): Basic survival is taken care of. Now I wanted to be able to hunt my opponents.\n* [The Event](#the-event): The competition consists of a \"Bounty Snake\" section where you can challenge the sponsors to duels. After that is the tournament itself composed of beginner, intermediate, and expert divisions.\n* [Conclusion](#conclusion): Super fun event! You should go!\n* [Code](https://github.com/tyrelh/battlesnake2018) for my 2018 entry is on Github.\n\n## Background\n\n[Battlesnake](https://www.battlesnake.io/) is a programming competition where competitors develop an AI to play a multiplayer version of the classic game [Snake](https://en.wikipedia.org/wiki/Snake_(video_game_genre)). Competitors can be individuals or groups; they are mainly students and industry professionals.\n\nMy first time entering the competition was this year, but the first version of the event was in 2013; it began as a small, friendly programming competition between a few colleagues at sendwithus (now [Dyspatch](https://www.dyspatch.io/sendwithus/)).\n\nA “snake” is essentially an API (Application Program Interface). This API has several required endpoints such as `start` and `move`. For every move, the game server will send a POST request to each snake's `move` endpoint, with the entire game state in the body of the request. You have 250ms (including your network transit time) to respond with a move, either “up”, “down”, “left”, or “right”.\n\nOnce each snake has responded, the moves are played out on the board simultaneously. If a snake hits a wall or another snake's body, it dies. If a snake eats food, it grows by one segment. If two snakes collide head-on the smaller snake will die. The object of the game is to be the last snake alive.\n\nThe competition is divided into three categories: beginner, intermediate, and expert. Within each bracket there is a round-robin tournament to determine the winners.\n\nDuring the day-long event there are many different activities. Early in the day there is the opportunity for newcomers to set up and begin developing their AI from scratch. Experienced developers are there to provide assistance in developing and deploying fresh snakes. Midway through the day are the bounty snake challenges; sponsors of the event challenge participants to duel their snakes for prizes. Sponsors with bounty snakes can opt to have their own unique rules to the game, forcing challengers to adapt their strategies the day of the event. Prizes for besting a bounty snake vary from t-shirts and stickers, to entries into a raffle for bigger prizes. Around 4pm, the main tournament begins. Starting with the beginner division, each tournament is played out on a big screen for all the participants to watch. The whole thing is also [streamed on Twitch](https://www.twitch.tv/battlesnakeofficial). Prizes of up to $4,000 are awarded for a podium placing.\n\n![Conference room full of people working on their laptops during the event](Battlesnake2018-2.jpg)\n\n## First Year Competing\n\nGoing into this I wasn’t sure what to expect. I just just really getting into the idea of software development in my second year of a Computer Science degree and was eager to try out some of my new skills.\n\nOne of the great (and overwhelming!) things about a competition like this is that there are essentially infinite ways of approaching the task. Some people do tree searches through the possible board states, some people build a more specific AI architecture, some even have started incorporating machine learning into their snakes. I’m not sure if any strategy is the best strategy, and this is just me documenting my journey and particular strategies as I became fascinated with this game.\n\n## Getting Started\n\nI decided to write my first entry in Python. I had been into Java for a while with school and was excited to learn Python; and what a better opportunity. I began with one of the [provided “starter snakes”](https://github.com/BattlesnakeOfficial/starter-snake-node) which are basic repositories with a simple server setup with the required endpoints, but no logic within those endpoints. Generally the starter snakes just `move` up upon a move request.\n\nWith the starter snake as a base, my first goal was to get the snake to chase its tail. Circling on your own tail seems to be a tried-and-tested method for basic survival so that seemed like a good place to start. Looping over an array of directions and returning a new one each time lets you blindly return a new direction each time. This sort of works, but the snake is still unaware of its surroundings and will still bump into walls, other snakes and even itself occasionally. The snake really needs some eyes so it can see if the next move is deadly or ok.\n\nI decided the simplest was to do this was to build myself a representation of the board. Each turn you are sent the board dimensions (which don’t change during the course of a round, but could change round-to-round), locations of all the snakes (for each snake a list of the positions of each body segment), and a list of food locations. At the start of each turn, I build a 2-dimensional array representing the game board, and plot all the snakes and food on it. I set up a simple numbering system representing the different possible board cells in a sort of increasing danger rating. 0 for space, 1 for food, 2 for snake body, and out of bounds represents the board edges. Now, after I pick a move, I can determine what the x, y coordinates of that move will be based on my current location, and I can check if that move will kill me or not based on the current board state. If it is deadly, pick another move. Basic sight!\n\nWith just this simple start your snake can spin around in a circle and survive for a while. The problem now is that you have an ever decreasing amount of health, and you need to eat food to replenish it. You begin with 100 health, and each move you take this is decremented by 1. If you reach 0 you die. So you have to eat! But in order to find food reliably when you are getting hungry, your snake will need more smarts that just its basic sense of sight.\n\n## Learning the A* Algorithm\n\nIn order to choose a move that will get you closer to a particular destination, you will need to implement some form of pathfinding. When looking into pathfinding algorithms, [A*](https://en.wikipedia.org/wiki/A*_search_algorithm) almost always comes up at the top of the list. I would struggle to explain A*, but the resource I used to initially learn and implement the algorithm was a video from [Daniel Shiffman](https://shiffman.net/) titled [A* Pathfinding Algorithm](https://www.youtube.com/watch?v=aKYlikFAV4k). He guides you through the algorithm and you can follow along and implement it in JavaScript with the [p5.js](https://p5js.org/) library. You can find my original implementation on [Github](https://github.com/tyrelh/a-star-p5.js). Also if you are building your snake with JavaScript and NodeJS, you can just reuse this code! For my first snake I translated this code into Python.\n\nWith this algorithm you can find the shortest path between a start point and a destination. Your start point will likely be your current head location, and the first destination point I choose was the closest food. I originally wrote this algorithm with my snake’s head and the closest food sort of hard-wired in, but later refactored it so that I can pass in any arbitrary start and destination points I want. Also within the algorithm you want to tell it to treat out of bounds as well as all snake body segments as “no go” areas. Basically the walls or obstacles that you are finding a path around. Within the search function I wrote, once you have found the optimal path to your destination, what you actually need from it is which direction to go next. Basically every turn you will be doing this search and just moving whatever it tells you the next move should be. There is no sense in recording or remembering the whole path as the game is filled with other snakes that are also moving every turn, so the optimal path may change from turn to turn.\n\nOne other thing to note is that there is often no path to where you want to go. Maybe a food exists on the board but is completely blocked from you on the current turn by other snakes. You just want to make sure you are handling situations like this gracefully and avoiding exceptions or other “panic” behaviour that might creep up. Develop a strategy for when you are unsure which move will get you closer to your destination.\n\nAn optimisation to the earlier tail-following behavior is that you can now use this A* algorithm to find the best move that brings you closer to your tail! You can just pass your tail location to the algorithm rather than a food location as the destination. This is a more robust way to follow your tail rather than looping through a series of moves as I initially implemented. Using the A* search allows you to be any size and anywhere on the board. It also makes it so you can follow yourself clockwise or counter-clockwise depending on which is better given the board state, as well as navigate effectively if you are touching other snakes.\n\nNow that my snake could find food it could survive much longer than 100 turns! At this level you could be well into the beginner category. Unfortunately every time you improve your snakes smarts and survivability, new problems pop up. The next glaring issue that I began to notice is that my snake loved to travel down dead ends. The snake was smart enough to find a food and seek it out, but not to plan for what would happen after it got to it.\n\n## Building a Flood Fill Algorithm\n\nThe behaviour I thought of to combat this tendency was an algorithm to measure how large a space was. If the space is too small to fit, or if another direction would lead to a large open area, the snake would take that into account when choosing the next move.\n\nSidenote: This was the moment when I should have realized that a move scoring system was the way to go. Next year I would implement this with great success, but this first year I basically stuck to a bunch of `if`/`else` statements. It is really difficult to balance the importance of different signals if you don’t have some kind of weights on them that you can tune. For example, if you have two possible moves, left and right, and there is food to the left, but much more space to the right, how do you value them? Which move do you choose? With a scoring system, you can apply a score to each move and sum them up in the end, choosing the move with the highest score. This is what I went on to build next year, but more on that in a different post.\n\nI believe what I was doing last year was testing to see if my snake length could fit into the area accessible by my next move. I would do my A* search first to see which direction I would prefer to go, and then do the flood fill on that move to see if I can fit. If I couldn’t fit I would choose a different move, abandoning my pursuit of food. This approach helps you to avoid these small areas that will easily trap you, but tramples over a lot of subtlety. For example, if there are snake tails within the area, that area will be expanding, so it is much more strategic for you to move into it. In the same vein, if there are snake heads within the area, the space will fill up as the game progresses. Taking these into consideration is a really good idea.\n\nA great tip for beginner programmers is that when you are developing and writing these algorithms, try to write them in reusable ways. Avoid hard-coding your snake to behave in one way.\n\n## Basic Behaviour Switching\n\nMy snake at this point has two different behaviors available to it. The first is to follow its own tail and the second is to seek out food. So long as you wrote your search algorithms in a way that you can pass any destination to them, it is pretty trivial to switch between these behaviours.\n\nAll I did to start was to switch between them based on my health level. If my health remaining was high, I would follow my tail. If my health was low, I would seek out food. This behaviour is what has become known as “chicken-snake” behaviour. Before I learned about Battlesnake, a now infamous player first developed this basic strategy to much success (coming in 2nd overall I believe). I guess people thought it looked like a chicken running around with it’s head cut off (sorry for the imagery).\n\nSo long as your algorithms are robust, and your snake doesn't make very many mistakes, this technique can still get you pretty far, perhaps even into the expert bracket. But because this behaviour became so popular, I decided I would actually see if I could build my snake to counter it.\n\n## Aggressive Behaviour\n\nNow that my snake had some basic survival skills, I wanted to try to do something a little different. I got the idea of trying to make my snake actively aggressive towards its opponents.\n\nWhen two snakes move in to the same space it is a head-on collision, and the rules state that if one snake is larger than the other the smaller snake will die. When a snake dies in the game all of its body segments are immediately removed from the board.\n\nSo my plan was to use my A* algorithm to seek out other snake heads. Strictly speaking, I would not target their head, but target the next move that then can make. So I altered my initial board state creation to mark `KILL_ZONE` for spaces a smaller snake than me could move next, and `DANGER_ZONE` for spaces a larger or equal size snake than me could move next. So now my board had these possible cell states:\n\n1. `SPACE`\n2. `KILL_ZONE`\n3. `FOOD`\n4. `DANGER_ZONE`\n5. `SNAKE_BODY`\n\nI ranked them in order of danger so that in my A* algorithm when testing if a cell is a valid spot for a path I can simply test if its board value is \u003c `SNAKE_BODY`.\n\nNow with the `KILL_ZONE` markings available, I could simply find the one closest to myself and use my A* to target it.\n\nThe next thing I wanted to do was to insure I was the biggest snake on the board, so that I could aggress any other snake I wanted. In the section of my code where I was determining which behaviour to use, I would not only test to see if I needed to eat because of hunger, but also if I needed to eat because I wasn’t the longest snake on the board. This behaviour works well sometimes but it has the fatal flaw that there can be other snakes with the same behaviour. You both can get into a feeding frenzy where you are always trying to get bigger than the other snake. You end up getting really long and it is only a matter of time before one of you makes a mistake and gets trapped. I did not fix this issue for this year and it seemed alright, just something to keep in mind.\n\nSo now my snake will eat if it is hungry or if there are any larger snakes, and it will target the nearest smaller snake if it is the largest on the board. I actually found that this simple behaviour has some really interesting and powerful emergent behaviours that I didn’t code for.\n\nThe first that I noticed is that it is very effective at dealing with the “chicken-snake” strategy. As a chicken snake is spinning away, minding its own business, my snake would be targeting its head. Since the other snake is smaller and spinning in a ball, my snake would wrap around it, trapping it. When the “chicken-snake” decided it had been spinning for long enough and it was time to eat, there was nowhere to go. Chances were that it might not be able to escape and get to food. If I didn’t kill it first by a head-on collision, I might be able to starve it.\n\nThe other interesting behaviour I noticed is similar to above, but instead of surrounding the opponent snake, I would block it against a wall. My snake wasn’t smart enough to notice if it could create a dead end for the other snake, but it could keep it against the wall for a long time, starving it.\n\nThis aggressive behaviour actually seemed to work very well. 1-1 my snake was quite strong at this point (a friend of mine who went on to win 2nd place in the intermediate division I could defeat almost all the time 1-1).\n\nThere are a few oversights in my strategy up to this point that I was aware of, but had run out of time to address. One was the eating behaviour that could lead to me getting very big and potentially kill myself. Another was that I didn’t necessarily need to be the biggest snake on the board at all times. There are plenty of opportunities to act aggressive to larger snakes while staying small. And lastly, but more importantly, there were still tons of small bugs and edge cases that I just wasn’t accounting for. There were still cases where given two possible moves, my snake was unable to see far enough ahead, or see in enough detail, to choose the best one. Building a robust logging solution is a must so that you can look back one a game to the move where your snake made a vital decision and you can debug why it may have made the wrong one. I had some basic console logging at this point but nothing nearly good enough.\n\nBut time to work on it was winding down, and the event was coming up.\n\n## The Event\n\nIn the morning people can converse and mingle, and newcomers can get help on getting their snakes setup and working. It’s great to hang out with your friends and work through some of your last bugs. Then lunch is provided by a bunch of great food trucks from around town. [Dead Beetz](https://www.deadbeetz.com/) is definitely my favorite go-to burger!\n\nAfter lunch the Bounty Snake challenge opens to everyone. This part is a lot of fun. You are able to visit each sponsor’s booth where they usually have some free swag. But also, more crucially, they have a snake of their own that you can challenge to a dual. Each sponsor has different prizes available to competitors who can defeat their snake. This year I actually won a terrific prize of $1000 from the local company [Rooof](https://www.rooof.com/)!\n\nAround 4:00 is when the actual competition begins. The setup this year was fantastic. They had two projectors showing the live games to an audience of around 800 people. They had live commentary and were also streaming the entire event live on [Twitch](https://www.twitch.tv/battlesnakeofficial). They do each bracket separately moving from Beginner to Intermediate and then Expert.\n\nI participated in Beginner this year as it was my first event. I was actually a little worried that my snake was too strong for beginner as I knew that some people entering had only started on their AI that day. Well I would be proven very wrong on that front. I won the first round I played and made it to the next head which was very exciting indeed. But alas I was knocked out in the next round, seemingly to some kind of bug (my snake hit another snake with possible move to avoid it existing). Oh well! It was so much fun to watch all the other snakes compete and to see everyones interesting and novel strategies. The top player in the expert division won $5,000, and in his little acceptance speech he said he was very glad to win as this money will partly cover his AWS bills for his snake! Holy cow!\n\nDuring the tournament, the music playlist left much to be desired. This gem came on part way through the night and everyone thought it was a custom \"Battlesnake\" theme song and loved it! Only later did we learn they were saying \"rattlesnake\" not \"battlesnake\".\n\n\u003cdiv className=\"video-container\"\u003e\n    \u003ciframe\n        width=\"853\"\n        height=\"480\"\n        title=\"King Gizzard and The Lizard Wizard - Rattlesnake\"\n        src=\"https://www.youtube.com/embed/Q-i1XZc8ZwA\"\n        frameBorder=\"0\"\n        allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\"\n        allowFullScreen\n    /\u003e\n\u003c/div\u003e\n\n## Conclusion\nI think this is such a great event to participate in. The challenge itself of creating an AI to play this game a great way to practice and build your coding skills. Everyone has the same 250ms to respond to each move request, but what you do in that time is all up to you. It is accessible to beginner programmers, but still an interesting challenge for a seasoned professional. I had a great time connecting with other students and industry professionals. I see myself participating every year that I can!\n\nMy code for 2018 is available on [Github](https://github.com/tyrelh/battlesnake2018).\n\nI'll see you next year,\nZeroCool"},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"battlesnake-2018"},"buildId":"_A1aUm7lgmk1WrrLd9Xyv","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>